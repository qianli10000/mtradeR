#' @title Simulation for a temporal high-dimensional OTU counts table based on StatSim output
#' @param base_par A high-dimensional compositional vector as Dirichlet-Multinomial baseline parameter.
#' @param StatSim A data matrix of disease status, identifiers, and the other covariates, generated by StatSim().
#' @param library.size The mean level of metagenomic sequencing library size.
#' @param min.lib The minimum threshold for sample-wise library size.
#' @param trace Prints out the simulated true relative abundance of the first 10 taxa. Defaults to TRUE.
#' @export

TaxaSim<-function(base_par,StatSim, shift_subject=0, library.size=100000,min.lib=10000,trace=TRUE){

  G=length(base_par)
  disp=1/(sum(base_par)+1)
  pi_i=colMeans(dirmult::rdirichlet(1000,(base_par*disp*(1-0.04)/((1-disp)*0.04))))
  otu.list=result.list.joint.onerand=result.list.joint.tworand=result.list.zibr.onerand=result.list.zibr.tworand=result.list.lmm.onerand=result.list.lmm.tworand=list()

    raw.counts=pi_star=pi_0=NULL
    for(i in 1:max(StatSim$ageset.id)){

      cat('Age group:',i,'\n')
      if(trace){
      print(pi_i[1:10])
      }
      set_i=unique(StatSim$set[StatSim$ageset.id==i])

      pi_i_star=pi_i
      sum1=(1-sum(pi_i[1:floor(G/2)]))*(i-1)/(max(StatSim$ageset.id))
      pi_i_star[1:floor(G/2)]=pi_i_star[1:floor(G/2)]+sum1*pi_i_star[1:floor(G/2)]/sum(pi_i_star[1:floor(G/2)])
      pi_i_star[(floor(G/2)+1):G]=pi_i_star[(floor(G/2)+1):G]-sum1*pi_i_star[(floor(G/2)+1):G]/sum(pi_i_star[(floor(G/2)+1):G])

      for(j in set_i){
        pi_i_star_bar=colMeans(dirmult::rdirichlet(1000,pi_i_star*(1-(0.05-0.005*(i-1)))/(0.05-0.005*(i-1))))

        pi_ij_0=pi_i_star_bar
        cat('Set:',j,'\n')
        if(trace){
        print(pi_ij_0[1:10])
        }
        sub_j=rownames(StatSim)[StatSim$set==j & StatSim$ageset.id==i]

        pi_ij_star=pi_ij_0

        pseudo.lam1=0.9 # permute pseudo.lam1= 0.5,0.9

        sum2=pseudo.lam1*sum(pi_ij_star[1:floor(G/4)])*(as.numeric(unique(StatSim$Rand_set.cut[StatSim$set==j]))-1)/(max(as.numeric(StatSim$Rand_set.cut))-1)
        pi_ij_star[1:floor(G/4)]=pi_ij_star[1:floor(G/4)]*(1-pseudo.lam1*(as.numeric(unique(StatSim$Rand_set.cut[StatSim$set==j]))-1)/(max(as.numeric(StatSim$Rand_set.cut))-1))
        pi_ij_star[(floor(G/4)+1):G]=pi_ij_star[(floor(G/4)+1):G]+sum2*pi_ij_star[(floor(G/4)+1):G]/sum(pi_ij_star[(floor(G/4)+1):G])


        for(k in sub_j){
          pi_ij_star_bar=colMeans(dirmult::rdirichlet(1000,(pi_ij_star*(1-(0.03))/(0.03))))
          pi_ijk_0=pi_ij_star_bar
          cat('Sample:',k,'\n')
          if(trace){
          print(pi_ijk_0[1:10])
          }
          pi_ijk_star=pi_ijk_0

          pseudo.lam2=shift_subject

          sum3=pseudo.lam2*(sum(pi_ijk_star[1:floor(G/2)])-sum(pi_ijk_star[1:floor(G/8)]))*(as.numeric(unique(StatSim[k,]$Rand_sub.cut))-1)/(max(as.numeric(StatSim$Rand_sub.cut))-1)
          pi_ijk_star[1:floor(G/8)]=pi_ijk_star[1:floor(G/8)]+sum3*pi_ijk_star[1:floor(G/8)]/sum(pi_ijk_star[1:floor(G/8)])
          pi_ijk_star[(floor(G/8)+1):floor(G/2)]=pi_ijk_star[(floor(G/8)+1):floor(G/2)]*(1-pseudo.lam2*(as.numeric(unique(StatSim[k,]$Rand_sub.cut))-1)/(max(as.numeric(StatSim$Rand_sub.cut))-1))


          #pi_star=cbind(pi_star,as.matrix(pi_ijk_star_bar))


          N_ijk=max(stats::rpois(n = 1,lambda = library.size),min.lib)
          Y_ijk=stats::rmultinom(n =1, size=N_ijk,prob = pi_ijk_star)
          raw.counts=cbind(raw.counts,Y_ijk)
        }

      }
    }


    colnames(raw.counts)=rownames(StatSim)
    return(raw.counts)
}
