#' @title Simulation for a temporal high-dimensional OTU counts table based on StatSim output
#' @param base_par A high-dimensional compositional vector as Dirichlet-Multinomial baseline parameter.
#' @param StatSim A data matrix of disease status, identifiers, and the other covariates, generated by StatSim().
#' @param shift_subject Shift size between two subjects with value between 0 and 1. 
#' @param library.size The mean level of metagenomic sequencing library size.
#' @param min.lib The minimum threshold for sample-wise library size.
#' @param trace Prints out the simulated true relative abundance of the first 10 taxa. Defaults to TRUE.
#' @export

TaxaSim<-function(base_par,StatSim, shift_subject=0, library.size=100000,min.lib=10000,trace=TRUE){
  cat('It may take a while to generate metagenomes...','\n')
  
  G=length(base_par)
  disp=1/(sum(base_par)+1)
  pi_i=colMeans(dirmult::rdirichlet(150,(base_par*disp*(1-0.04)/((1-disp)*0.04))))
  otu.list=result.list.joint.onerand=result.list.joint.tworand=result.list.zibr.onerand=result.list.zibr.tworand=result.list.lmm.onerand=result.list.lmm.tworand=list()

    raw.counts=pi_star=pi_0=NULL
    for(i in 1:max(StatSim$ageset.id)){

      if(trace){
      cat('Age group:',i,'\n')
      print(pi_i[1:10])
      }
      set_i=unique(StatSim$set[StatSim$ageset.id==i])

      pi_i_star=pi_i
      sum1=(1-sum(pi_i[1:floor(G/2)]))*(i-1)/(max(StatSim$ageset.id))
      pi_i_star[1:floor(G/2)]=pi_i_star[1:floor(G/2)]+sum1*pi_i_star[1:floor(G/2)]/sum(pi_i_star[1:floor(G/2)])
      pi_i_star[(floor(G/2)+1):G]=pi_i_star[(floor(G/2)+1):G]-sum1*pi_i_star[(floor(G/2)+1):G]/sum(pi_i_star[(floor(G/2)+1):G])

      for(j in set_i){
        pi_i_star_bar=colMeans(dirmult::rdirichlet(150,pi_i_star*(1-(0.05-0.005*(i-1)))/(0.05-0.005*(i-1))))

        pi_ij_0=pi_i_star_bar
        
        if(trace){
        cat('Set:',j,'\n')
        print(pi_ij_0[1:10])
        }
        sub_j=rownames(StatSim)[StatSim$set==j & StatSim$ageset.id==i]

        pi_ij_star=pi_ij_0

        lam1=0.9 # permute lam1= 0.5,0.9

        sum2=lam1*sum(pi_ij_star[1:floor(G/4)])*(as.numeric(unique(StatSim$Rand_set.cut[StatSim$set==j]))-1)/(max(as.numeric(StatSim$Rand_set.cut))-1)
        pi_ij_star[1:floor(G/4)]=pi_ij_star[1:floor(G/4)]*(1-lam1*(as.numeric(unique(StatSim$Rand_set.cut[StatSim$set==j]))-1)/(max(as.numeric(StatSim$Rand_set.cut))-1))
        pi_ij_star[(floor(G/4)+1):G]=pi_ij_star[(floor(G/4)+1):G]+sum2*pi_ij_star[(floor(G/4)+1):G]/sum(pi_ij_star[(floor(G/4)+1):G])


        for(k in sub_j){
          pi_ij_star_bar=colMeans(dirmult::rdirichlet(50,(pi_ij_star*(1-(0.03))/(0.03))))
          pi_ijk_0=pi_ij_star_bar
          
          if(trace){
          cat('Sample:',k,'\n')
          print(pi_ijk_0[1:10])
          }
          pi_ijk_star=pi_ijk_0

          lam2=shift_subject 
          
          sum3=lam2*(sum(pi_ijk_star[1:floor(G*0.5)])-sum(pi_ijk_star[1:floor(G*0.15)]))*(as.numeric(StatSim[k,]$Rand_sub.cut)-1)/(max(as.numeric(StatSim$Rand_sub.cut))-1)
          
          pi_ijk_star[1:floor(G*0.15)]=pi_ijk_star[1:floor(G*0.15)]+sum3*pi_ijk_star[1:floor(G*0.15)]/sum(pi_ijk_star[1:floor(G*0.15)])
          pi_ijk_star[(floor(G*0.15)+1):floor(G*0.3)]=pi_ijk_star[(floor(G*0.15)+1):floor(G*0.3)]*(1-lam2*(as.numeric(StatSim[k,]$Rand_sub.cut)-1)/(max(as.numeric(StatSim$Rand_sub.cut))-1))
          
          sum4=lam2*(sum(pi_ijk_star[1:floor(G*0.5)])-sum(pi_ijk_star[1:floor(G*0.3)]))*(as.numeric(StatSim[k,]$Rand_sub.cut)-1)/(max(as.numeric(StatSim$Rand_sub.cut))-1)
          
          if(as.numeric(StatSim[k,]$Rand_sub.cut)==2){
            rid=sample((floor(G*0.3)+1):floor(G),size = floor(G*0.4))
            while(sum(pi_ijk_star[rid])<sum4){
              rid=sample((floor(G*0.3)+1):floor(G),size = floor(G*0.4))
            }
          }else{
            rid=(floor(G*0.3)+1):floor(G)
          }
          pi_ijk_star[rid]=pi_ijk_star[rid]*(1-sum4/sum(pi_ijk_star[rid]))


          N_ijk=max(stats::rpois(n = 1,lambda = library.size),min.lib)
          Y_ijk=stats::rmultinom(n =1, size=N_ijk,prob = pi_ijk_star)
          raw.counts=cbind(raw.counts,Y_ijk)
        }

      }
    }

    raw.counts=ifelse(raw.counts<10,0,raw.counts)
    colnames(raw.counts)=rownames(StatSim)
    return(raw.counts)
}
